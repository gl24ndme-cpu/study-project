1. Переменные в JavaScript (var, let, const), строгий режим (use strict). Как называть переменные?

Переменная - сущность, предназначання для хранения данных, можно объявить с помощью:
    var - объявление переменной по старому типу, можно использовать до ее фактического объявления, но будет undefined
    const - объявление константной переменной, невозможно перезаписать или переопределить
    let - объвление переменной в современном виде, почти то же самое, что и var, только нельзя использовать ее до инициализации

Существует строгий режим (use Strict) - позволяющий писать правильнее и чище

Именуем переменные с помощью CamelCase, такое мы уже знаем с C#.

2. Типы данных в JavaScript. Проверка типов (typeof), преобразование типов. Интерполяция строк.

Есть типы данных:
    string - строки, могут заключаться в: 'строка', "строка", или бектики `вот ${интерполяция} так`, также ее можно растянуть на несколько строк
    number - обычные числа, но не настолько большие до ~9 квадриллионов. Можно писать также как (const number = 1_000_000)
    bigInt - большие числа > 9 квадриллионов, пишется как 100n, допустим
    boolean - булевый тип, логический: true, false
    null - специальное значение, пустое или неизвестное, часто присваивают тем, которые ожидают значение
    undefined - пустое, значение не присвоено, просто объявили и не присвоили
    object - const user = {}, сложный тип данных, все остальные примитивные, все, что создается с помощью ключевого слова New

Чтобы проверить тип данных можно использовать - typeof, допустим:
    typeof 100 - вернет number
    typeof string - вернет string
    typeof null - вернет object
    typeof {} - вернет object

Преобразования типов данных бывают явные и неявные:
    
    неявные:
        Из number в string:
            const num = 111
            const str = '222'
            const result = num + str // Здесь число 111 превратится в строку '111' и сконкатенировалось все в итоге в = 111222
        
        Из string в number:
            console.log('16'/'8') // Выведет 2, то есть number, потому что перед тем как поделить оно попытается переварить это в то, что можно поделить то есть number
        
        Чаще всего это просто антипаттерн

    явные:
        
        String()
            Допустим есть переменная const age = 11, можно использовать String(age), чтобы получить строку '11'.
        
        Number()
            Можно снова использовать Number(String(age)) - чтобы получить 11 в числовом значении.
            Если преобразовать с помощью Number(boolean) - то мы получим либо 1, либо 0.
        Boolean()
            Если использовать на пустую строку '' - получим false, если хоть что-то есть - получим true.

3. Математика в JavaScript. Арифметические операторы, операторы сравнения. Декремент и инкремент.

Бинарные операторы - те, которые применяются к двум числам, слева и справа

Унарные операторы - те, которые применяются к одному числу, типа (-5)
    Одним из них является оператор: +'1000' = 1000, +'null' = 0, +'true' = 1, применяется к нечисловым типам данных превращая их в числа.

Нестрогое и строгое сравнение:
    Нестрогое - "==", проверяет только значение самих переменных без типов данных
    Строгое - "===", проверяет кроме значения также и сам тип данных, допустим '11' === 11 --> выдаст false

4. JavaScript условия if else. Тернарный оператор. Логические операторы. Оператор нулевого слияния.

Тернарный оператор:
    const year = 2024;
    const message = year === 2024 ? 'Начинаю учиться' : 'Неизвестный год'
                      (условие)         (при true)         (при false)
    То есть допустим:
        function getFee(isMember) {
        return "The fee is " + (isMember ? "$2.00" : "$10.00");
        }
        при true выведет $2, при false $10

        console.log(num > 10 ? 'Число больше 10' : 'Число меньше или равно 10')

Оператор !: 
    Все, что null, undefined или пустая строка - даст нам false, остальное - true.

Прием с оператором &&:
    const age = 16
    const isYoung = age < 18 (true)
    
    isYoung && console.log('Покажите паспорт') // если выражение слева является true, то выражение справа выполнится, такое стоит избегать!

Оператор нулевого слияния:
    const result1 = a ?? b 
    если левая часть либо null, либо undefined, то вернет правую часть, если нет, то вернет первую часть

5. JavaScript функции alert, prompt и confirm для взаимодействия с пользователем. Условия switch case.

alert('Привет') - Окошко на сайте
prompt - Такое же окошко, только с полем ввода
confirm - Возвращает true или false (Выбор ок или нет)

6. Циклы в JavaScript — while, do while и for. Прерывание цикла break. Продолжение цикла continue.

Это понятно, циклы while, do while, for, for in

7. Функции в JavaScript. Область видимости. Параметры и аргументы. Значения по умолчанию. Return.

Способы объявить функцию:
    
    1. function functionName(Параметры функции) {Тело функции **console.log(arguments)** } - Такую функцию можно использовать до ее объявления в коде HOISTING, возможно ее перезаписать.
        **Насчет аргументов, есть неявная переменная arguments, доступ к ней можно получить внутри тела функции только с помощью этого вида объявления функции.
        Еще одна особенность работа с ключевым словом this, рассмотрим позже.

    2. const functionName = (Параметры функции) => {Тело функции} - Переопределить нельзя, если const, нельзя использовать до ее объявления, у стрелочной функции нет контекста.
        можно неявно возвратить, если записать в одну строку - const sum = (a, b) => a + b

    3. (Параметры функции) => {Тело функции}  

При обращении без парных скобок по типу function(), а просто function выдаст кое-что интересное:
    console.log(function) нам выдаст свое содержимое

Важно отметить, что при объявлении функции пишутся параметры, а при вызове функции даются аргументы**

Значения параметров функции по умолчанию:
    function logMessage (message, count = 1) {} - Допустим, при вызове функции logMessage('Привет') мы передадим только один аргумент message, все равно будет работать корректно

Возврат значений:
    Если мы не укажем значение return - то нам всегда будет возвращать undefined

8. Виды функций в JavaScript. Стрелочные функции. Как правильно называть функции? Назначение функций.

Существуют функции Колбэки, принимающие как аргументы другие функции. 
const logMessage = (actionBefore, actionAfter) => {
    actionBefore()
    console.log('Привет')
    actionAfter()
}

const f1 = () => console.log('before')
const f2 = () => console.log('before')

logMessage(f1, f2) // Можно упростить и не передавать функции переменными, а сделать вот так --> logMessage(() => console.log('before'), () => console.log('before'))
    БЕЗ СИНТАКСИСА () => ИНСТРУКЦИЯ, НЕЛЬЗЯ, потому что обычно они вычисляются до выполнения функции и неявно возвращают undefined.

9. Объекты в JavaScript. Свойства объекта — чтение, добавление, удаление, проверка наличия и перебор.

Объявление объекта:
    const object = {
        login: 'login'
        password:'password'
        key: 'value'
        object: { 
            city: 'Moscow'
        }
        sayHi: () => console.log('Привет') // Метод в объекте
    }

К свойству объекта можно получить доступ:
    console.log(object.login) // console.log(object['login'])

ЕСЛИ ОБРАТИТЬСЯ К НЕСУЩЕСТВУЕЩЕМУ ПОЛЮ В ОБЪЕКТЕ - выдаст undefined (console.log(object.blabla) // undefined)

Чтобы добавить в объект свойство достаточно лишь:
    const user = {}
    user.name = 'Карим'
    console.log(user.name) // Карим

    Для проверки есть ли свойство в объекте можно использовать оператор in, допустим: console.log('name' in user) // true

10. JavaScript объекты — сравнение, копирование, объединение, деструктуризация, остаточные параметры.

Объект - ссылочный тип, значит и при сравнении будут сравниваться ссылками - то есть результат будет false
    
Опциональная цепочка:

    const user = {
        name: 'Александр',
        age: 28,
        address: {
            // city: 'Moscow',
            zipcode: 123456,
        },
    }

    Если попытаться прочитать свойство так:
        console.log(user.address.city) - То нам выдаст undefined, если же пойти дальше и закомментировать сам объект address, то нам выдаст ошибку, потому что у undefined нет свойств.
        
        Один из вариантов использовать опицональную цепочку, оператор состоит из двух символов - ?.
        Допустим - console.log(user.address?.city) - Если в user есть объект address и оно вообще является объектом, то мы обращаемся к city

        Самый банальный пример в SPA:
        const userInfo = await fetchUserInfo() // Мы получаем данные асинхронно, то есть там может и не быть информации

        renderUserName(userInfo?.name) // Здесь стоит применить optional chaining
        renderCatalog()

Деструктуризация объекта:
    const user = {
        name: 'Alexander',
        age: 28,
        isDeveloper: true,
    }

    const name = user.name
    const age = user.age
    const isDeveloper = user.isDeveloper

    const { name, age, isDeveloper } = user // Абсолютно равнозначно тому, что было выше

    Также можно привести еще один пример деструктуризации:

        const logAddress = (address) => {
            console.log (`Адрес: ${address.city}, ул. ${address.street}, д. ${address.houseNumber}, кв.{address.apartmentNumber}`)
        }

        Здесь у нас в функцию подается именно объект address со своими полями

        logAddress({ // Запись объекта сразу в функцию
            city: 'Moscow'
            street: 'Pushkina'
            houseNumber: '1'
            apartmentNumber: '1'
        })

        ЗДЕСЬ Деструктурировать можно вообще множеством способов, зачем нам постоянно писать address, если можно сделать так:

        
        const logAddress = (address) => {
        const {city, street, houseNumber, apartmentNumber} = address // Вот так
            console.log (`Адрес: ${city}, ул. ${street}, д. ${houseNumber}, кв.{apartmentNumber}`) // Получится намного короче
        }

        А МОЖНО даже сделать это в параметрах функции:

        const logAddress = ({city, street, houseNumber, apartmentNumber}) => {
            console.log (`Адрес: ${city}, ул. ${street}, д. ${houseNumber}, кв.{apartmentNumber}`) // Получится намного короче
        }

Смена имени при деструктуризации:

    const user = {
        name: 'Alexander'
    }

    const admin = {
        name: 'Admin'
    }

    const { name } = user 

    const { name } = admin // Так сделать не получится, потому что сверху мы уже заняли место

    НО МОЖНО сделать смену имени:

    const { name: userName } = user

    const { name: adminName } = admin // Хорошо

Значение по умолчанию при деструктуризации:

    Вообще бывают случаи, когда у одного объекта есть какие-либо поля, а у некоторых нет, поэтому воспользуемся этим:

    const user = {
        // city = 'Moscow'
    }

    const userAddon = {
        city = 'St. Petersburg'
    }

    const { city: userCity = 'Не указан город' } = user


    console.log(`Город: ${userCity}`) // Если мы вывели бы без значения по умолчанию - был бы udnefined

Остаточные параметры:

Допустим есть такой код:

    const logUser = (user) => {
        const { name, age, city } = user // ТУТ не указаны остальные параметры (НЕОБЯЗАТЕЛЬНЫЕ), можно воспользоваться синтаксисом:
        const { name, age, city, ...otherInfo } = user // ТУТ не указаны остальные параметры (НЕОБЯЗАТЕЛЬНЫЕ), можно воспользоваться синтаксисом:

        console.log(` ${name}, ${age}, ${city}`)

        console.log(`Доп информация: ${otherInfo}) // Тут будет объект с двумя полями компани и жобПост
    }

    logUser( {
        name: 'Alex',
        age: 18,
        city: 'Moscow'
        company: 'VK'
        jobPost: 'Front'
    })

Ну что, перейдем к this :)

11. Ключевое слово this в JavaScript для начинающих • this в объектах и функциях

let calculator = {
    read(a, b) {
        this.a = +prompt('Введите первое число:', 0) // с помощью this.a оно уже как бы создает новое поле свойство в JavaScript
        this.b = +prompt('Введите второе число:', 0)
    },
    sum() {
        return this.a + this.b
    },
    mul() {
        return this.a * this.b
    }
}

Чтобы можно было по цепочке вызывать методы, можно возаращать this в методы в объекте.


12. JavaScript методы примитивов. Числа. Объект Math. Округление чисел. Парсинг чисел из строк.

В JavaScript числа — это примитивные значения. Однако, когда вы обращаетесь к свойству или методу числа JavaScript временно оборачивает
его в специальный объект-обёртку (Number), который предоставляет доступ к полезным методам.

toFixed(digits)
    let num = 123.456;
    let str = num.toFixed(2); // num временно оборачивается в объект Number
    console.log(str); // "123.46" // Округляет число до кол-ва знаков после запятой

toPrecision(precision)
    let bigNum = 1234.567;
    let precisionNum = bigNum.toPrecision(5); // "1234.6" - Возвращает строковое представление числа, округленного до указанного общего числа значимых цифр (до и после десятичной точки).


toString(radix)
    let decimal = 255;
    let hex = decimal.toString(16); // "ff"
    let binary = decimal.toString(2); // "11111111" Возвращает строковое представление числа. Можно указать систему счисления (radix) для преобразования (по умолчанию 10).

Объект Math не является конструктором и не имеет отношения к объектам-оберткам. Это глобальный объект, содержащий математические константы и функции для выполнения более сложных операций.
    
    Math.random(): Возвращает псевдослучайное число с плавающей точкой в диапазоне от 0 (включительно) до 1 (исключительно).

    Math.pow(base, exponent): Возвращает основание в степени экспоненты.
    Math.pow(2, 3) // 8 (2 * 2 * 2)

    Math.sqrt(x): Возвращает квадратный корень числа.

    Math.max(x, y, ...) / Math.min(x, y, ...): Возвращает наибольшее/наименьшее число из переданных аргументов.

Парсинг чисел из строк:

parseInt(string, radix) (Парсинг целых чисел): Читает строку и возвращает целое число. Парсинг останавливается на первом нечисловом символе. Можно указать систему счисления (radix).

    parseInt("100px") // 100
    parseInt("15.99") // 15
    parseInt("0xff", 16) // 255 (шестнадцатеричное)

parseFloat(string) (Парсинг чисел с плавающей точкой): Читает строку и возвращает число с плавающей точкой. Парсинг также останавливается на первом нечисловом символе, но учитывает первую точку.

    parseFloat("12.5em") // 12.5
    parseFloat("3.14.159") // 3.14 (останавливается на второй точке)

13. Строки в JavaScript. Методы at, replace, slice, includes, repeat, trim, split. Длина строки length.

1) Свойства и доступ к символам
    Длина строки (length) Свойство length возвращает числовое значение, равное количеству символов в строке. Пробелы и другие символы также учитываются.
    
    Доступ по индексу ([]) Позволяет получить символ по его индексу, начиная отсчет с 0. Отрицательные индексы не поддерживаются и возвращают undefined.
    Чтобы получить последний символ, используйте выражение str[str.length - 1].

    Метод at(index) Возвращает символ по указанной позиции, но, в отличие от квадратных скобок, поддерживает отрицательные индексы.
    str.at(-1) возвращает первый символ с конца (последний символ).

2) Изменение регистра
    
    toLowerCase(): Преобразует все символы строки в нижний регистр.
    toUpperCase(): Преобразует все символы строки в верхний регистр.

3) Удаление пробелов
    
    trim(): Обрезает пробельные символы только в начале и конце строки.
    trimStart() (или trimLeft): Обрезает пробелы только в начале строки.
    trimEnd() (или trimRight): Обрезает пробелы только в конце строки.

4) Поиск подстроки

    indexOf(substring, start) Возвращает индекс первого вхождения подстроки. 
    message.indexOf('фывфывфывфыв') !== -1; // Значит результат сравнения равен false, подстрока не найдена
    Если подстрока не найдена, возвращает -1. Вторым необязательным аргументом можно указать индекс, с которого начинать поиск.
    
    includes(substring, start) Возвращает true или false в зависимости от того, содержится ли указанная подстрока в строке. Вторым необязательным аргументом можно указать индекс, с которого начинать поиск.

    startsWith(substring, start) Проверяет, начинается ли строка с указанной подстроки. Вторым необязательным аргументом можно указать индекс, с которого начинать поиск.
    endsWith(substring, length) Проверяет, оканчивается ли строка на указанную подстроку. Вторым аргументом можно указать длину строки, которая будет считаться концом для проверки.

5) Все эти методы возвращают новую подстроку, не изменяя исходную:

    substring(start, end) Извлекает подстроку, начиная с индекса start и до индекса end (не включая его).
    Позволяет передавать аргументы в любом порядке (меньший индекс всегда будет началом).

    slice(start, end) Работает схожим образом с substring, но имеет ключевые отличия:
    Не позволяет менять аргументы местами (если start > end, вернет пустую строку). Поддерживает отрицательные индексы. Например, slice(-6) вернет последние 6 символов строки.

6) Модификация и повторение
    repeat(count) Возвращает новую строку, которая является результатом повторения исходной строки указанное количество раз.
    replace(pattern, replacement) Заменяет первое найденное вхождение pattern на replacement.

    В качестве pattern может принимать строку или регулярное выражение.
    replaceAll(pattern, replacement) Заменяет все вхождения pattern на replacement.
    
    Работа с регулярными выражениями Для замены всех вхождений с помощью replace можно использовать регулярное выражение с флагом g (global). Флаг i (case-insensitive) позволяет искать без учета регистра.

7) Метод split()
    split(separator) Разбивает строку на массив подстрок, используя указанный separator (разделитель).
    Если в качестве разделителя указать пустую строку "", метод вернет массив, где каждый элемент — отдельный символ строки.

8) Важный принцип: Неизменяемость (Immutability)
    Крайне важно помнить, что все перечисленные методы строк не мутируют (не изменяют) исходную строку.
    Каждый метод возвращает новую строку с внесенными изменениями. Чтобы сохранить результат, его необходимо присвоить переменной:

14. Методы массивов JavaScript — forEach, map, filter, reduce, some, every, sort, includes, indexOf

Массив в JavaScript — это специальный тип объекта, предназначенный для хранения упорядоченных коллекций данных. Элементы массива доступны по числовому индексу, который начинается с 0.

Перебор массива:
    Вообще есть перебор массива с помощью цикла for.

    1) Метод letters.forEach((element, index, array) => {console.log(element)}) // Эта функция колбэк, index - счетчик цикла, array - сам массив

    2) prices.indexOf(element, start) - находит индекс, второй аргумент - индекс с которого начинать поиск

    А что если надо найти объекты?:

    3) users.findIndex(user) => user.name === 'Василий')
    let users = [
        { name: 'Александр', age: 28 },
        { name: 'Василий', age: 30 },
        { name: 'Пётр', age: 40 },
        { name: 'Василий', age: 50 }, // Второй Василий
    ];

    // 1. findIndex: Найти ИНДЕКС первого "Василия"
    let vasiliyIndex = users.findIndex(user => user.name === 'Василий');
    console.log(vasiliyIndex); // 1 [00:09:36]

    // 2. find: Найти САМ ПЕРВЫЙ объект "Василий"
    let firstVasiliy = users.find(user => user.name === 'Василий');
    console.log(firstVasiliy); // { name: 'Василий', age: 30 } [00:12:35]

    // 3. filter: Найти ВСЕХ "Василиев"
    let allVasilievs = users.filter(user => user.name === 'Василий');
    console.log(allVasilievs); 
    // [ { name: 'Василий', age: 30 }, { name: 'Василий', age: 50 } ] [00:13:00]

    // 4. filter: Сложная фильтрация (город Москва ИЛИ возраст < 45)
    let filteredUsers = users.filter(user => {
        // Предполагая, что в объектах есть свойство 'city'
        return user.city === 'Москва' || user.age < 45;
    });

    4) Преобразование: map()
    let users = [
    { name: 'Александр', age: 28 },
    { name: 'Василий', age: 30 }
    ];

    // Преобразуем массив объектов в массив информационных строк
    let usersFormatted = users.map(user => {
        // Используем шаблонные строки (обратные кавычки)
        return `Имя: ${user.name}, Возраст: ${user.age} лет.`;
    });

    console.log(usersFormatted);
    /*
    [
    "Имя: Александр, Возраст: 28 лет.",
    "Имя: Василий, Возраст: 30 лет."
    ] 
    */

    5) Проверка условий: some()
    
    let users = [
        { name: 'Пётр', age: 40 },
        { name: 'Анна', age: 25 },
    ];


    let hasVasiliy = users.some(user => user.name === 'Василий');
    console.log(hasVasiliy); // false

    let isAnyoneOlderThan30 = users.some(user => user.age > 30);
    console.log(isAnyoneOlderThan30); // true (так как у Петра 40)

    6) every

    array.every(function callback(element, index, array) {
        // ... условие проверки ...
    });

    7) reduce

JavaScript и JSON формат — парсинг и преобразование данных.

Вообще бывают случаи, когда нужно отправить объект на сервер

15. Классы в JavaScript — объявление, конструктор, наследование, экземпляр, геттеры и сеттеры

В основном классы примерно такие же как и C#

1) Ключевое слово super - Важная деталь:
c
lass Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    // Метод родителя
    eat() {
        console.log(`${this.name} кушает.`);
    }
}

class Developer extends Person {
    constructor(name, age, experience) {
        super(name, age); // Вызывает Конструктор класса родителя, просто так определить эти свойства мы не можем!!
        this.experience = experience; // Добавляем новое свойство
    }

    // Переопределение метода родителя (Override)
    eat() {
        super.eat(); // Вызываем оригинальный метод "Person кушает."
        console.log("...и смотрит уроки по CSS."); // Добавляем свою логику
    }

    writeCode() {
        console.log("Пишет код.");
    }
}

const dev = new Developer("Алекс", 35, 10);
dev.eat(); 
// Алекс кушает.
// ...и смотрит уроки по CSS.

16. JavaScript Отложенное и регулярное выполнение кода — setTimeout и setInterval, clearTimeout и др.

1) SetTimeout: 
function logMessage(name, age) {
    alert(`Имя: ${name}, Возраст: ${age}`);
}

// SetTimeout выполнит logMessage через 3 секунды, передав 'Вася' и 21
setTimeout(logMessage, 3000, "Вася", 21); // 

2) Отмена таймера: clearTimeout 
let timerID = setTimeout(() => {
    alert("Этот код не выполнится!");
}, 5000);

// Отменяем таймер немедленно
clearTimeout(timerID);

3) Функция setInterval используется для регулярного выполнения кода через фиксированные промежутки времени
 
// Выводит "Привет" каждую секунду
let intervalID = setInterval(() => {
    console.log("Привет");
}, 1000);

4) Неточность setInterval
Главное отличие setInterval от setTimeout в том, что setInterval не гарантирует, что предыдущий вызов коллбэк-функции завершился до того, как запланирован следующий.

Если код внутри коллбэка занимает больше времени, чем заданный интервал, последующие вызовы могут "накладываться" или выполняться с мгновенной задержкой, что нарушает ожидаемый ритм
Более точный аналог: Вложенный setTimeout
Для создания рекурсивного выполнения, которое гарантирует, что следующий вызов произойдет спустя заданное время ПОСЛЕ завершения предыдущего, используют вложенный setTimeout

function logMessage() {
    // Код, который может выполняться долго
    console.log("Выполнение..."); 
    
    // Генерируем новый таймер только после завершения текущего кода
    setTimeout(logMessage, 1000); 
}

// Запускаем первый вызов
setTimeout(logMessage, 1000);

Нулевая задержка (0 мс) и цикл событий
Даже если вы установите задержку 0 мс в setTimeout, код не выполнится немедленно. Это связано с тем, что:

JavaScript однопоточен: Код, запланированный таймером, помещается в очередь событий (Event Queue) и может быть выполнен только после того, как основной поток (Call Stack) завершит выполнение всего синхронного кода [07:55].

Минимальная задержка: В браузерах существует стандартная минимальная задержка для setTimeout, которая обычно составляет 4 миллисекунды, даже если вы указали 0
Таким образом, setTimeout(..., 0) используется не для немедленного выполнения, а для откладывания кода в конец очереди выполнения (в обход синхронного кода).

17. Обработка ошибок в JavaScript — try catch finally, throw, класс Error

try	Содержит потенциально ошибочный код. Если в этом блоке возникает ошибка, выполнение кода в try немедленно прекращается, и управление переходит к блоку catch.
catch (error)	Содержит код, который выполняется только в случае возникновения ошибки в блоке try. В скобках (error) мы получаем объект с деталями об ошибке.

1) Пример:
let names = undefined; // Имитируем ошибку

try {
    // Потенциально проблемный код
    names.forEach(name => console.log(name)); // Здесь возникнет ошибка
    console.log("Этот код не выполнится"); // Пропускается
} catch (error) {
    // Код, который выполнится, если в try была ошибка
    console.log("Возникла ошибка:", error.message); // Выводит сообщение об ошибке
}

console.log("Конец кода"); // Продолжит выполнение

2) Блок finally является опциональным дополнением к try...catch. Код, содержащийся в нем, выполняется всегда, независимо от того, была ли ошибка поймана в блоке try или нет

try {
    // ... код ...
} catch (error) {
    // ... обработка ...
} finally {
    // Этот код выполнится в любом случае (был ли try успешным или нет)
    console.log("Операция завершена.");
}

3) try...catch не может поймать ошибку, возникшую в асинхронном коде, который выполняется спустя время после завершения блока try (например, ошибка внутри setTimeout)
    РЕШЕНИЕ - Конструкцию try...catch необходимо перенести внутрь тела асинхронной функции




18. JavaScript событийный цикл Event Loop, асинхронный код, промисы (Promise), async / await
    


19. Модули в JavaScript: import и export (ES Modules)

Модули в JavaScript — это отдельные файлы, каждый из которых отвечает за конкретный функционал программы.
Они являются основой декомпозиции кода, то есть его разделения на мелкие, логически изолированные части.
Это повышает читаемость, упрощает поддержку и улучшает структуру большого проекта.

1) Объявление модуля: Чтобы файл воспринимался браузером как модуль, его нужно подключить в HTML с помощью тега <script> с атрибутом type="module" .

2) Изоляция (Область видимости): Файлы, объявленные как модули, имеют собственную, изолированную область видимости.
Это значит, что переменные, объявленные в одном модуле, недоступны напрямую в другом, что предотвращает конфликты и загрязнение глобального пространства.

3) Повторное выполнение: Код в JS-файле, который является модулем, выполняется ровно один раз, независимо от того, сколько раз он был подключен в HTML или импортирован в другие файлы

4) Порядок выполнения: Браузер выполняет код модулей после того, как отработают все обычные (немодульные) скрипты на странице.
Это позволяет модулям обращаться к элементам DOM-дерева без дополнительных задержек

Экспорт сущностей (export) - Экспорт используется для того, чтобы сделать переменные, функции или классы,
объявленные в модуле, доступными для использования в других файлах.

1) Именованный экспорт (Named Export) - Позволяет экспортировать несколько сущностей из одного файла:

Экспорт при объявлении: Ключевое слово export ставится перед объявлением сущности.

export const SELECTORS = { /* ... */ }; 
export function initTabs() { /* ... */ }

Список экспорта в конце файла: Сущности перечисляются в конце файла в фигурных скобках. 
Этот способ часто предпочтительнее для лучшей наглядности.

const SELECTORS = { /* ... */ };
function initTabs() { /* ... */ }

export { SELECTORS, initTabs };

2) Экспорт по умолчанию (Default Export)
Позволяет экспортировать только одну главную сущность из файла (функцию, класс или переменную).

// Пример экспорта функции по умолчанию
export default function init() {
    // ... логика инициализации модуля ...
}

3) Импорт сущностей (import)
Импорт используется для подключения экспортированных сущностей из другого модуля. Инструкция import всегда пишется в начале файла

Импорт именованных сущностей
Сущности импортируются по их оригинальным именам, указанным в фигурных скобках.

import { SELECTORS, initTabs } from './tabs.js';

// Переименование при импорте (если имена конфликтуют)
import { selectors as tabsSelectors } from './tabs.js';

Импорт сущности по умолчанию
Импортируется без фигурных скобок. При этом можно использовать любое имя для импортируемой сущности, так как она единственная, экспортированная по умолчанию.

// 'runTabs' — это произвольное имя, которое мы присвоили экспорту по умолчанию
import runTabs from './tabs.js';

!! Импорт всего содержимого модуля
Позволяет импортировать все именованные экспорты модуля в виде одного объекта с помощью синтаксиса import * as Name.
Экспорты доступны как свойства этого объекта. Экспорт по умолчанию доступен как свойство default.

// Импорт всех сущностей из файла constants.js
import * as Constants from './constants.js';

console.log(Constants.A); 
console.log(Constants.default()); // Вызов функции, экспортированной по умолчанию

4) Реэкспорт (Re-export) - это механизм, который позволяет импортировать сущности из одного файла и сразу же экспортировать их из другого.
Это удобно для создания индексных файлов (index.js), которые собирают экспорты из глубоких подпапок и делают их доступными по простому пути.

// index.js (находится в папке /constants)
// Экспортирует все именованные сущности из файла, лежащего глубже
export * from './folder1/folder2/constants.js';

После этого в главном файле можно импортировать данные по сокращенному пути:
// script.js
import { A, B } from './constants'; // Путь к папке, содержащей index.js


20. DOM в JavaScript — Навигация по элементам дерева, атрибуты async и defer

21. JavaScript DOM. Поиск элементов: getElement и querySelector
Использовать data-js